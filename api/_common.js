// api/_common.js
const { ethers } = require("ethers");
const fs = require("fs");
const path = require("path");

let provider, relayerWallet, addresses, walletFactoryAbi, simpleWalletAbi;
let isInitialized = false;

// A resilient loader that tries multiple common paths for a file in a Vercel env.
function loadJsonFile(baseName) {
  const triedPaths = [];

  // Attempt to `require` first, which works well with bundlers.
  try {
    const requiredModule = require(`../${baseName}`);
    return {
      json: requiredModule,
      raw: JSON.stringify(requiredModule),
      path: `require('../${baseName}')`,
      triedPaths,
    };
  } catch (e) {
    triedPaths.push(`require('../${baseName}'): ${e.message}`);
  }

  // Define a list of candidate paths to check.
  const candidatePaths = [
    path.join(process.cwd(), baseName), // Vercel copies `includeFiles` here.
    path.join(__dirname, "..", baseName), // Relative path from /api/_common.js to root.
    path.join(__dirname, baseName), // Path if file is in the same dir as the script.
    `/var/task/${baseName}`, // Absolute path in Vercel runtime.
    `/var/task/user/${baseName}`, // Another possible Vercel runtime path.
  ];

  for (const p of candidatePaths) {
    triedPaths.push(p);
    if (fs.existsSync(p)) {
      try {
        const raw = fs.readFileSync(p, "utf8");
        const json = JSON.parse(raw);
        return { json, raw, path: p, triedPaths };
      } catch (e) {
        // If the file exists but is malformed, we still want to stop and report it.
        console.error(
          `[common] Error parsing JSON from existing file: ${p}`,
          e
        );
        throw new Error(
          `Could not parse ${baseName} at ${p}. It may be corrupted.`
        );
      }
    }
  }

  // If we get here, the file was not found in any of the candidate paths.
  return { json: null, raw: null, path: null, triedPaths };
}

async function setup() {
  if (isInitialized) {
    return {
      provider,
      relayerWallet,
      addresses,
      walletFactoryAbi,
      simpleWalletAbi,
    };
  }

  const network = process.env.NETWORK || "sepolia";
  const RPC_URL =
    network === "sepolia"
      ? process.env.SEPOLIA_RPC_URL
      : process.env.LOCAL_RPC_URL || "http://127.0.0.1:8545";

  if (!RPC_URL)
    throw new Error(`[common] RPC URL for ${network} is not configured`);

  const RELAYER_PRIVATE_KEY =
    process.env.RELAYER_PRIVATE_KEY || process.env.PRIVATE_KEY;
  if (!RELAYER_PRIVATE_KEY)
    throw new Error("[common] RELAYER_PRIVATE_KEY (or PRIVATE_KEY) is not set");

  // ---- Load deployed-addresses.json ----
  const addrFile = loadJsonFile("deployed-addresses.json");
  if (!addrFile.json) {
    console.error(
      "[common] FATAL: Could not find deployed-addresses.json. Searched paths:",
      addrFile.triedPaths
    );
    throw new Error(
      "Deployment addresses not found. Ensure deployed-addresses.json is committed and included in Vercel deployment."
    );
  }
  addresses = addrFile.json;
  console.log(`[common] Loaded addresses from: ${addrFile.path}`);

  if (!addresses.factory || !ethers.isAddress(addresses.factory)) {
    throw new Error(
      `Invalid factory address in deployed-addresses.json: ${addresses.factory}`
    );
  }

  // ---- Load relayer-artifacts.json (ABIs) ----
  const abiFile = loadJsonFile("relayer-artifacts.json");
  if (!abiFile.json) {
    console.error(
      "[common] FATAL: Could not find relayer-artifacts.json. Searched paths:",
      abiFile.triedPaths
    );
    throw new Error(
      "ABI file relayer-artifacts.json not found. Ensure it is generated by the deploy script, committed, and included in Vercel deployment."
    );
  }
  console.log(`[common] Loaded ABIs from: ${abiFile.path}`);

  // --- SELF-DIAGNOSING VALIDATION ---
  // This is the most critical part. It checks the *content* of the loaded file.
  const { factoryAbi, walletAbi } = abiFile.json;
  if (
    !Array.isArray(factoryAbi) ||
    factoryAbi.length === 0 ||
    !Array.isArray(walletAbi) ||
    walletAbi.length === 0
  ) {
    // Log the raw content of the file to the server logs for definitive proof.
    console.error(
      "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
    );
    console.error(
      "!!! FATAL: The deployed relayer-artifacts.json file is malformed or empty."
    );
    console.error(
      "!!! This usually means an old, empty version of the file was committed to Git."
    );
    console.error("!!! RAW FILE CONTENT:", abiFile.raw);
    console.error(
      "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
    );

    // Throw a user-friendly error that will be sent to the frontend.
    throw new Error(
      "ABIs in relayer-artifacts.json are missing or empty. This is a deployment issue. Please run the deployment script locally, commit the generated file, and re-deploy to Vercel."
    );
  }

  walletFactoryAbi = factoryAbi;
  simpleWalletAbi = walletAbi;

  provider = new ethers.JsonRpcProvider(RPC_URL);
  relayerWallet = new ethers.Wallet(RELAYER_PRIVATE_KEY, provider);

  console.log(
    `[common] Setup complete. Relayer: ${relayerWallet.address} on network: ${network}`
  );

  isInitialized = true;
  return {
    provider,
    relayerWallet,
    addresses,
    walletFactoryAbi,
    simpleWalletAbi,
  };
}

// Centralized error response
const handleTransactionError = (error, res) => {
  const safeMsg =
    (error && (error.reason || error.message)) ||
    "An unexpected internal server error occurred.";
  console.error("--- API Transaction Error ---");
  // Log the full error stack for server-side debugging
  console.error(error);

  // Default to 500 but adjust for client-side errors if possible
  let status = 500;
  if (safeMsg.includes("Invalid") || safeMsg.includes("required")) status = 400;

  res.status(status).json({ success: false, error: safeMsg });
};

module.exports = { setup, handleTransactionError };
